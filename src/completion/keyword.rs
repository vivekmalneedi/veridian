use tower_lsp::lsp_types::*;

pub const KEYWORDS: &[(&str, &str)] = &[
    ("accept_on", ""),
    ("alias", ""),
    ("always", "always @($1) begin\nend"),
    ("always_comb", "always_comb @($1) begin\nend"),
    ("always_ff", "always_ff @($1) begin\nend"),
    ("always_latch", "always_latch @($1) begin\nend"),
    ("and", ""),
    ("assert", ""),
    ("assign", ""),
    ("assume", ""),
    ("automatic", ""),
    ("before", ""),
    ("begin", "begin\n\t$1\nend"),
    ("bind", ""),
    ("bins", ""),
    ("binsof", ""),
    ("bit", ""),
    ("break", ""),
    ("buf", ""),
    ("bufif0", ""),
    ("bufif1", ""),
    ("byte", ""),
    ("case", "case $1;\nendcase"),
    ("casex", "casex $1;\nendcase"),
    ("casez", "casez $1;\nendcase"),
    ("cell", ""),
    ("chandle", ""),
    ("checker", "checker $1;\nendchecker"),
    ("class", "class $1;\nendclass"),
    ("clocking", "clocking $1;\nendclocking"),
    ("cmos", ""),
    ("config", "config $1;\nendconfig"),
    ("const", ""),
    ("constraint", ""),
    ("context", ""),
    ("continue", ""),
    ("cover", ""),
    ("covergroup", ""),
    ("coverpoint", ""),
    ("cross", ""),
    ("deassign", ""),
    ("default", ""),
    ("defparam", ""),
    ("design", ""),
    ("disable", ""),
    ("dist", ""),
    ("do", ""),
    ("edge", ""),
    ("else", ""),
    ("end", ""),
    ("endcase", ""),
    ("endchecker", ""),
    ("endclass", ""),
    ("endclocking", ""),
    ("endconfig", ""),
    ("endfunction", ""),
    ("endgenerate", ""),
    ("endgroup", ""),
    ("endinterface", ""),
    ("endmodule", ""),
    ("endpackage", ""),
    ("endprimitive", ""),
    ("endprogram", ""),
    ("endproperty", ""),
    ("endspecify", ""),
    ("endsequence", ""),
    ("endtable", ""),
    ("endtask", ""),
    ("enum", ""),
    ("event", ""),
    ("eventually", ""),
    ("expect", ""),
    ("export", ""),
    ("extends", ""),
    ("extern", ""),
    ("final", ""),
    ("first_match", ""),
    ("for", ""),
    ("force", ""),
    ("foreach", ""),
    ("forever", ""),
    ("fork", ""),
    ("forkjoin", ""),
    ("function", "function $1;\nendfunction"),
    ("generate", "generate\n\t$1\nendgenerate"),
    ("genvar", ""),
    ("global", ""),
    ("highz0", ""),
    ("highz1", ""),
    ("if", ""),
    ("iff", ""),
    ("ifnone", ""),
    ("ignore_bins", ""),
    ("illegal_bins", ""),
    ("implements", ""),
    ("implies", ""),
    ("import", ""),
    ("incdir", ""),
    ("include", ""),
    ("initial", ""),
    ("inout", ""),
    ("input", ""),
    ("inside", ""),
    ("instance", ""),
    ("int", ""),
    ("integer", ""),
    ("interconnect", ""),
    ("interface", "interface $1;\nendinterface"),
    ("intersect", ""),
    ("join", ""),
    ("join_any", ""),
    ("join_none", ""),
    ("large", ""),
    ("let", ""),
    ("liblist", ""),
    ("library", ""),
    ("local", ""),
    ("localparam", ""),
    ("logic", ""),
    ("longint", ""),
    ("macromodule", ""),
    ("matches", ""),
    ("medium", ""),
    ("modport", ""),
    ("module", "module $1 ($2);\nendmodule"),
    ("nand", ""),
    ("negedge", ""),
    ("nettype", ""),
    ("new", ""),
    ("nexttime", ""),
    ("nmos", ""),
    ("nor", ""),
    ("noshowcancelled", ""),
    ("not", ""),
    ("notif0", ""),
    ("notif1", ""),
    ("null", ""),
    ("or", ""),
    ("output", ""),
    ("package", "package $1;\nendpackage"),
    ("packed", ""),
    ("parameter", ""),
    ("pmos", ""),
    ("posedge", ""),
    ("primitive", "primitive $1;\nendprimitive"),
    ("priority", ""),
    ("program", "program $1;\nendprogram"),
    ("property", "property $1;\nendproperty"),
    ("protected", ""),
    ("pull0", ""),
    ("pull1", ""),
    ("pulldown", ""),
    ("pullup", ""),
    ("pulsestyle_ondetect", ""),
    ("pulsestyle_onevent", ""),
    ("pure", ""),
    ("rand", ""),
    ("randc", ""),
    ("randcase", ""),
    ("randsequence", ""),
    ("rcmos", ""),
    ("real", ""),
    ("realtime", ""),
    ("ref", ""),
    ("reg", ""),
    ("reject_on", ""),
    ("release", ""),
    ("repeat", ""),
    ("restrict", ""),
    ("return", ""),
    ("rnmos", ""),
    ("rpmos", ""),
    ("rtran", ""),
    ("rtranif0", ""),
    ("rtranif1", ""),
    ("s_always", ""),
    ("s_eventually", ""),
    ("s_nexttime", ""),
    ("s_until", ""),
    ("s_until_with", ""),
    ("scalared", ""),
    ("sequence", "sequence $1;\nendsequence"),
    ("shortint", ""),
    ("shortreal", ""),
    ("showcancelled", ""),
    ("signed", ""),
    ("small", ""),
    ("soft", ""),
    ("solve", ""),
    ("specify", "specify $1;\nendspecify"),
    ("specparam", ""),
    ("static", ""),
    ("string", ""),
    ("strong", ""),
    ("strong0", ""),
    ("strong1", ""),
    ("struct", ""),
    ("super", ""),
    ("supply0", ""),
    ("supply1", ""),
    ("sync_accept_on", ""),
    ("sync_reject_on", ""),
    ("table", "table $1;\nendtable"),
    ("tagged", ""),
    ("task", "task $1;\nendtask"),
    ("this", ""),
    ("throughout", ""),
    ("time", ""),
    ("timeprecision", ""),
    ("timeunit", ""),
    ("tran", ""),
    ("tranif0", ""),
    ("tranif1", ""),
    ("tri", ""),
    ("tri0", ""),
    ("tri1", ""),
    ("triand", ""),
    ("trior", ""),
    ("trireg", ""),
    ("type", ""),
    ("typedef", ""),
    ("union", ""),
    ("unique", ""),
    ("unique0", ""),
    ("unsigned", ""),
    ("until", ""),
    ("until_with", ""),
    ("untyped", ""),
    ("use", ""),
    ("uwire", ""),
    ("var", ""),
    ("vectored", ""),
    ("virtual", ""),
    ("void", ""),
    ("wait", ""),
    ("wait_order", ""),
    ("wand", ""),
    ("weak", ""),
    ("weak0", ""),
    ("weak1", ""),
    ("while", ""),
    ("wildcard", ""),
    ("wire", ""),
    ("with", ""),
    ("within", ""),
    ("wor", ""),
    ("xnor", ""),
    ("xor", ""),
];

pub fn keyword_completions(keywords: &[(&str, &str)]) -> Vec<CompletionItem> {
    let mut items: Vec<CompletionItem> = Vec::new();
    for key in keywords {
        if key.1.is_empty() {
            items.push(CompletionItem {
                label: key.0.to_string(),
                kind: Some(CompletionItemKind::Keyword),
                ..CompletionItem::default()
            });
        } else {
            items.push(CompletionItem {
                label: key.0.to_string(),
                kind: Some(CompletionItemKind::Keyword),
                insert_text: Some(key.1.to_string()),
                insert_text_format: Some(InsertTextFormat::Snippet),
                ..CompletionItem::default()
            })
        }
    }
    items
}

pub fn sys_task_completions(tasks: &[&str]) -> Vec<CompletionItem> {
    tasks
        .iter()
        .map(|x| CompletionItem {
            label: x.to_string(),
            kind: Some(CompletionItemKind::Function),
            ..CompletionItem::default()
        })
        .collect()
}

pub const SYS_TASKS: &[&str] = &[
    "finish",
    "exit",
    "fatal",
    "warning",
    "stop",
    "error",
    "info",
    "realtime",
    "time",
    "asserton",
    "assertkill",
    "assertpasson",
    "assertfailon",
    "assertnonvacuouson",
    "stime",
    "printtimescale",
    "timeformat",
    "bitstoreal",
    "bitstoshortreal",
    "itor",
    "signed",
    "cast",
    "realtobits",
    "shortrealtobits",
    "rtoi",
    "unsigned",
    "sampled",
    "fell",
    "changed",
    "past_gclk",
    "fell_gclk",
    "changed_gclk",
    "rising_gclk",
    "steady_gclk",
    "bits",
    "typename",
    "isunbounded",
    "coverage_control",
    "coverage_get",
    "coverage_save",
    "set_coverage_db_name",
    "dimensions",
    "right",
    "high",
    "size",
    "random",
    "dist_erlang",
    "dist_normal",
    "dist_t",
    "asin",
    "acos",
    "atan",
    "atan2",
    "hypot",
    "sinh",
    "cosh",
    "tanh",
    "asinh",
    "acosh",
    "atanh",
    "q_initialize",
    "q_remove",
    "q_exam",
    "q_add",
    "q_full",
    "async$and$array",
    "async$nand$array",
    "async$or$array",
    "async$nor$array",
    "sync$and$array",
    "sync$nand$array",
    "sync$or$array",
    "sync$nor$array",
    "countones",
    "onehot0",
    "fatal",
    "warning",
    "dist_chi_square",
    "dist_exponential",
    "dist_poisson",
    "dist_uniform",
    "countbits",
    "onehot",
    "isunknown",
    "coverage_get_max",
    "coverage_merge",
    "get_coverage",
    "load_coverage_db",
    "clog2",
    "ln",
    "log10",
    "exp",
    "sqrt",
    "pow",
    "floor",
    "ceil",
    "sin",
    "cos",
    "tan",
    "rose",
    "stable",
    "past",
    "rose_gclk",
    "stable_gclk",
    "future_gclk",
    "falling_gclk",
    "changing_gclk",
    "unpacked_dimensions",
    "left",
    "low",
    "increment",
    "assertoff",
    "assertcontrol",
    "assertpassoff",
    "assertfailoff",
    "assertvacuousoff",
    "error",
    "info",
    "async$and$plane",
    "async$nand$plane",
    "async$or$plane",
    "async$nor$plane",
    "sync$and$plane",
    "sync$nand$plane",
    "sync$or$plane",
    "sync$nor$plane",
    "system",
    "countdrivers",
    "getpattern",
    "incsave",
    "input",
    "key",
    "list",
    "log",
    "nokey",
    "nolog",
    "reset",
    "reset_count",
    "reset_value",
    "restart",
    "save",
    "scale",
    "scope",
    "showscopes",
    "showvars",
    "sreadmemb",
    "sreadmemh",
];
